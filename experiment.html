<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gaze Estimation Experiment</title>
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <script src="/mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:'Segoe UI',system-ui,sans-serif;background:#0d1117;color:#e6edf3;min-height:100vh}
    body.cursor-hidden,body.cursor-hidden *{cursor:none !important}
    .phase{display:none;min-height:100vh}
    .phase.active{display:flex;flex-direction:column}

    /* â”€â”€ Camera widget (select page only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #cam-widget{margin-top:20px;display:flex;flex-direction:column;align-items:center;gap:6px}
    #cam-video-wrap{position:relative;width:240px;height:180px;border-radius:10px;border:2px solid #30363d;overflow:hidden;background:#0d1117}
    #cam-preview{width:240px;height:180px;object-fit:cover;display:block;transform:scaleX(-1)}
    #cam-canvas{position:absolute;top:0;left:0;width:240px;height:180px;pointer-events:none;transform:scaleX(-1)}
    #cam-status{font-size:.75rem;color:#8b949e}
    /* â”€â”€ Heatmap thumbnail in results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .dc-heatmap{width:100%;height:auto;display:block;border-radius:6px;margin-top:8px;border:1px solid #30363d}

    /* â”€â”€ Gaze dot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #gaze-dot-exp{
      position:fixed;width:20px;height:20px;border-radius:50%;
      background:rgba(88,166,255,0.55);border:2px solid #58a6ff;
      box-shadow:0 0 12px rgba(88,166,255,0.8);
      transform:translate(-50%,-50%);pointer-events:none;
      z-index:8500;display:none
    }

    /* â”€â”€ Phase 0 â€“ Select â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ph-select{
      align-items:center;justify-content:center;
      padding:40px 20px;text-align:center
    }
    #ph-select h1{font-size:1.8rem;color:#58a6ff;margin-bottom:8px}
    #ph-select>p{color:#8b949e;margin-bottom:32px;font-size:0.95rem}
    .method-grid{
      display:grid;grid-template-columns:repeat(3,1fr);
      gap:20px;max-width:920px;width:100%;margin:0 auto 32px
    }
    .mc{
      background:#161b22;border:2px solid #30363d;border-radius:12px;
      padding:24px 20px;cursor:pointer;transition:border-color .2s,transform .15s;
      text-align:left
    }
    .mc:hover{border-color:#58a6ff;transform:translateY(-2px)}
    .mc.sel{border-color:#58a6ff;background:rgba(88,166,255,.08)}
    .mc h3{color:#58a6ff;font-size:1rem;margin-bottom:6px}
    .mc .desc{color:#8b949e;font-size:.82rem;margin-bottom:12px;line-height:1.5}
    .mc ul{list-style:none;margin-bottom:16px}
    .mc ul li{font-size:.8rem;color:#8b949e;padding:2px 0}
    .mc ul li::before{content:'âœ“ ';color:#3fb950}
    .mc .tag{
      display:inline-block;padding:2px 8px;border-radius:4px;
      font-size:.72rem;font-weight:700
    }
    .tag-wg{background:rgba(88,166,255,.2);color:#58a6ff}
    .tag-ml{background:rgba(63,185,80,.2);color:#3fb950}
    .tag-poly{background:rgba(240,192,0,.2);color:#f0c000}

    /* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .btn{
      padding:10px 22px;border-radius:8px;border:none;cursor:pointer;
      font-size:.9rem;font-weight:600;transition:opacity .2s,background .2s
    }
    .btn:disabled{opacity:.35;cursor:not-allowed}
    .btn-green{background:#238636;color:#fff}
    .btn-green:hover:not(:disabled){background:#2ea043}
    .btn-blue{background:#1f6feb;color:#fff}
    .btn-blue:hover:not(:disabled){background:#388bfd}
    .btn-grey{background:#21262d;color:#e6edf3;border:1px solid #30363d}
    .btn-grey:hover:not(:disabled){background:#30363d}
    .btn-red{background:#b62324;color:#fff}
    .btn-red:hover:not(:disabled){background:#da3633}
    .btn-save{background:#6e40c9;color:#fff}
    .btn-save:hover:not(:disabled){background:#8957e5}

    /* Previous runs list */
    #runs-list{max-width:920px;width:100%;text-align:left;margin-bottom:24px}
    #runs-list h3{color:#8b949e;font-size:.85rem;margin-bottom:8px;letter-spacing:.5px}
    .run-item{
      display:flex;align-items:center;gap:10px;
      padding:8px 12px;background:#161b22;border:1px solid #30363d;
      border-radius:6px;margin-bottom:6px;font-size:.82rem
    }
    .run-item .ri-method{color:#58a6ff;font-weight:700;min-width:120px}
    .run-item .ri-dist{color:#3fb950;min-width:80px}
    .run-item .ri-time{color:#8b949e}
    .ri-dots{display:flex;gap:4px;flex-wrap:wrap}
    .ri-dot-chip{
      padding:1px 6px;border-radius:3px;font-size:.72rem;background:#21262d;color:#e6edf3
    }

    /* â”€â”€ Phase 1 â€“ Calibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ph-calibrate{position:relative;background:#0d1117}
    #cal-overlay{
      position:fixed;inset:0;background:rgba(13,17,23,.96);
      z-index:900;display:none
    }
    #cal-overlay.show{display:block}
    .cal-dot{
      position:absolute;width:42px;height:42px;border-radius:50%;
      transform:translate(-50%,-50%);cursor:pointer;
      border:3px solid #58a6ff;background:rgba(88,166,255,.1);
      display:flex;align-items:center;justify-content:center;
      font-size:.72rem;font-weight:700;color:#58a6ff;
      user-select:none;transition:border-color .2s
    }
    .cal-dot.active{
      border-color:#f0c000;color:#f0c000;
      background:rgba(240,192,0,.15);animation:cpulse .8s infinite
    }
    .cal-dot.done{
      border-color:#3fb950;color:#3fb950;
      background:rgba(63,185,80,.2);cursor:default;
      transform:translate(-50%,-50%) scale(.85)
    }
    .cal-dot.collecting{border-color:#f0c000;color:#f0c000}
    @keyframes cpulse{
      0%,100%{transform:translate(-50%,-50%) scale(1)}
      50%{transform:translate(-50%,-50%) scale(1.18)}
    }
    #cal-info{
      position:fixed;top:25%;left:50%;
      transform:translate(-50%,-50%);
      text-align:center;pointer-events:none;z-index:910;
      background:rgba(13,17,23,.88);border:1px solid #30363d;
      border-radius:10px;padding:14px 24px;
      backdrop-filter:blur(6px);min-width:300px
    }
    #cal-info h2{color:#58a6ff;margin-bottom:6px;font-size:1rem}
    #cal-info p{color:#8b949e;font-size:.82rem;line-height:1.5}
    #cal-prog{color:#e6edf3;margin-top:6px;font-size:.9rem}
    #cal-bar-wrap{
      width:200px;height:6px;background:#21262d;
      border-radius:3px;margin:10px auto 0;overflow:hidden
    }
    #cal-bar-fill{
      height:100%;width:0%;background:#f0c000;
      border-radius:3px;transition:width .1s
    }
    #cal-msg{
      margin-top:10px;font-size:.8rem;
      color:#f85149;min-height:18px
    }

    /* â”€â”€ Phase 2 â€“ Experiment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ph-experiment{
      position:relative;background:#0d1117;
      justify-content:center;align-items:center
    }
    #exp-dot{
      position:fixed;width:32px;height:32px;border-radius:50%;
      transform:translate(-50%,-50%);
      background:rgba(240,192,0,.9);border:3px solid #f0c000;
      box-shadow:0 0 24px rgba(240,192,0,.7);
      display:none;z-index:810;pointer-events:none
    }
    #exp-dot.show{display:block}
    #exp-status{
      position:fixed;top:25%;left:50%;transform:translate(-50%,-50%);
      background:rgba(22,27,34,.92);border:1px solid #30363d;
      border-radius:10px;padding:14px 28px;text-align:center;
      z-index:820;min-width:280px
    }
    #exp-status h3{color:#58a6ff;font-size:1rem;margin-bottom:4px}
    #exp-timer{font-size:2.2rem;font-weight:700;color:#e6edf3;margin:4px 0}
    #exp-progress{font-size:.82rem;color:#8b949e}
    #exp-collect-badge{
      display:inline-block;padding:2px 10px;border-radius:12px;
      font-size:.75rem;font-weight:700;margin-top:6px;
      background:rgba(248,81,73,.2);color:#f85149
    }
    #exp-collect-badge.collecting{
      background:rgba(63,185,80,.2);color:#3fb950
    }

    /* â”€â”€ Phase 3 â€“ Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ph-results{
      padding:40px 24px;overflow-y:auto;
      justify-content:flex-start
    }
    .results-hdr{
      display:flex;justify-content:space-between;align-items:flex-start;
      flex-wrap:wrap;gap:12px;margin-bottom:28px
    }
    .results-hdr h1{color:#58a6ff;font-size:1.4rem}
    .results-hdr .sub{color:#8b949e;font-size:.85rem;margin-top:4px}
    .btn-row{display:flex;gap:10px;flex-wrap:wrap}
    .section{margin-bottom:40px}
    .section h2{
      color:#58a6ff;font-size:1rem;margin-bottom:16px;
      border-bottom:1px solid #21262d;padding-bottom:8px;
      letter-spacing:.3px
    }
    /* 9-dot wave grid */
    .dot-grid{
      display:grid;grid-template-columns:repeat(3,1fr);
      gap:14px;margin-bottom:20px
    }
    .dot-card{
      background:#161b22;border:1px solid #30363d;
      border-radius:10px;padding:14px
    }
    .dc-hdr{
      display:flex;justify-content:space-between;
      align-items:center;margin-bottom:6px
    }
    .dc-hdr h4{color:#e6edf3;font-size:.88rem}
    .dc-dist{font-size:.88rem;font-weight:700}
    .dc-dist.good{color:#3fb950}.dc-dist.ok{color:#f0c000}.dc-dist.bad{color:#f85149}
    .dc-pos{font-size:.72rem;color:#8b949e;margin-bottom:8px}
    .dc-chart{width:100%;height:110px;display:block}

    /* Summary table */
    .tbl{width:100%;border-collapse:collapse}
    .tbl th,.tbl td{
      padding:9px 14px;text-align:left;
      border-bottom:1px solid #21262d;font-size:.83rem
    }
    .tbl th{color:#8b949e;font-weight:600}
    .tbl td{color:#e6edf3}
    .tbl tr.total td{font-weight:700;color:#58a6ff;border-bottom:none}

    /* Comparison */
    .cmp-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .cmp-card{
      background:#161b22;border:1px solid #30363d;
      border-radius:10px;padding:18px
    }
    .cmp-card h3{color:#e6edf3;font-size:.95rem;margin-bottom:12px}
    .cmp-method-tag{
      display:inline-block;padding:2px 8px;border-radius:4px;
      font-size:.75rem;font-weight:700;margin-left:8px
    }
    .cmp-big-chart{background:#161b22;border:1px solid #30363d;border-radius:10px;padding:18px;margin-top:16px}
    .cmp-big-chart h3{color:#e6edf3;font-size:.95rem;margin-bottom:12px}

    /* Toast */
    #toast{
      position:fixed;bottom:24px;left:50%;transform:translateX(-50%);
      background:#238636;color:#fff;padding:10px 24px;border-radius:8px;
      font-size:.88rem;z-index:9999;display:none;pointer-events:none
    }

    @media(max-width:700px){
      .method-grid{grid-template-columns:1fr}
      .dot-grid{grid-template-columns:1fr}
      .cmp-grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>

<!-- â”€â”€â”€ Gaze dot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="gaze-dot-exp"></div>

<!-- â”€â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="toast">Saved!</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 0 â€“ Method Selection
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ph-select" class="phase active">
  <h1 style="color:#58a6ff;font-size:1.9rem;margin-bottom:6px">Eye Gaze Estimation Experiment</h1>
  <p style="color:#8b949e;margin-bottom:32px">
    Compare 3 gaze estimation methods using a 9-dot accuracy test
  </p>

  <div class="method-grid">
    <!-- WebGazer -->
    <div class="mc" id="mc-webgazer" onclick="selectMethod('webgazer')">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h3>WebGazer</h3><span class="tag tag-wg">Method 1</span>
      </div>
      <p class="desc">Ridge Regression on eye-patch appearance features via WebGazer.js</p>
      <ul>
        <li>Machine-learning gaze regression</li>
        <li>Click-based calibration (N clicks Ã— 9 pts)</li>
        <li>Adapts to appearance changes</li>
      </ul>
      <label style="display:flex;align-items:center;gap:8px;margin-top:10px;font-size:.82rem;color:#8b949e;cursor:default" onclick="event.stopPropagation()">
        Clicks per dot:
        <input id="wg-clicks-input" type="number" min="1" max="20" value="5"
          onclick="event.stopPropagation()"
          style="width:54px;padding:4px 6px;border-radius:6px;border:1px solid #30363d;
                 background:#0d1117;color:#e6edf3;font-size:.85rem;text-align:center"/>
      </label>
    </div>
    <!-- Iris Linear -->
    <div class="mc" id="mc-iris-linear" onclick="selectMethod('iris-linear')">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h3>Iris Linear</h3><span class="tag tag-ml">Method 2</span>
      </div>
      <p class="desc">Linear regression mapping iris-to-eye-corner ratio â†’ screen coordinates</p>
      <ul>
        <li>Uses MediaPipe iris landmarks 468â€“473</li>
        <li>Gaze-only calibration (look, then click)</li>
        <li>Lightweight & interpretable</li>
      </ul>
    </div>
    <!-- Iris Polynomial -->
    <div class="mc" id="mc-iris-poly" onclick="selectMethod('iris-poly')">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h3>Iris Polynomial</h3><span class="tag tag-poly">Method 3</span>
      </div>
      <p class="desc">Polynomial regression on iris features for non-linear gaze mapping</p>
      <ul>
        <li>6 polynomial features (x, y, xÂ², yÂ², xy)</li>
        <li>Better handles off-axis gaze angles</li>
        <li>More flexible than linear mapping</li>
      </ul>
    </div>
  </div>

  <div style="margin-bottom:20px">
    <button class="btn btn-green" id="btn-start-exp" onclick="beginCalibration()" disabled>
      Start Calibration â†’
    </button>
  </div>

  <!-- Previous runs -->
  <div id="runs-list" style="display:none">
    <h3>COMPLETED RUNS</h3>
    <div id="runs-list-inner"></div>
    <div style="margin-top:12px;display:flex;gap:10px">
      <button class="btn btn-blue" id="btn-view-compare" onclick="showPhase('ph-results')">
        View Results &amp; Comparison
      </button>
      <button class="btn btn-grey" onclick="clearAllRuns()">Clear All</button>
    </div>
  </div>

  <!-- Camera preview with landmarks â€” visible only on select page -->
  <div id="cam-widget">
    <div id="cam-video-wrap">
      <video id="cam-preview" autoplay playsinline muted></video>
      <canvas id="cam-canvas"></canvas>
    </div>
    <div id="cam-status">Starting cameraâ€¦</div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 1 â€“ Calibration overlay
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ph-calibrate" class="phase">
  <div id="cal-overlay">
    <!-- Calibration dots rendered by JS -->
    <div id="cal-info">
      <h2 id="cal-title">Calibration</h2>
      <p id="cal-desc"></p>
      <div id="cal-prog"></div>
      <div id="cal-bar-wrap"><div id="cal-bar-fill"></div></div>
      <div id="cal-msg"></div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 2 â€“ Pre-experiment briefing
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ph-ready" class="phase" style="align-items:center;justify-content:center;padding:40px 20px">
  <div style="max-width:560px;width:100%;background:#161b22;border:1px solid #30363d;border-radius:14px;padding:36px 40px;text-align:center">
    <div style="font-size:2rem;margin-bottom:12px">ğŸ‘</div>
    <h2 id="ready-title" style="color:#58a6ff;margin-bottom:6px">Calibration Complete</h2>
    <p id="ready-method" style="color:#8b949e;font-size:.85rem;margin-bottom:24px"></p>

    <div style="text-align:left;background:#0d1117;border-radius:10px;padding:20px 24px;margin-bottom:28px;font-size:.88rem;line-height:1.8">
      <div style="color:#e6edf3;font-weight:600;margin-bottom:10px">How the experiment works</div>
      <ul style="color:#8b949e;padding-left:18px;margin:0">
        <li><span style="color:#e6edf3">9 dots</span> will appear one by one on screen</li>
        <li>Each dot is shown for <span style="color:#e6edf3">10 seconds</span></li>
        <li>The first <span style="color:#e6edf3">1 second</span> is a settling pause â€” just move your gaze to the dot</li>
        <li>The remaining <span style="color:#e6edf3">9 seconds</span> collect gaze data (~15 samples/s)</li>
        <li><span style="color:#e6edf3">Look directly at each dot</span> and keep your head still</li>
        <li>The mouse cursor will be <span style="color:#e6edf3">hidden</span> during the experiment</li>
        <li>Press <kbd style="background:#21262d;border:1px solid #30363d;border-radius:4px;padding:1px 5px;font-size:.8rem;color:#e6edf3">H</kbd> to show/hide the gaze estimation dot</li>
      </ul>
    </div>

    <button class="btn btn-green" onclick="startExperiment()" style="font-size:1rem;padding:12px 40px">
      Start Experiment â†’
    </button>
    <div style="margin-top:12px">
      <button class="btn btn-grey" onclick="showPhase('ph-select')" style="font-size:.8rem">â† Back to Menu</button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 3 â€“ Experiment
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ph-experiment" class="phase">
  <div id="exp-dot"></div>
  <div id="exp-status">
    <h3 id="exp-method-name">â€“</h3>
    <div id="exp-timer">â€“</div>
    <div id="exp-progress">Dot 1 / 9</div>
    <div id="exp-collect-badge">Waiting 1sâ€¦</div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
      <button id="btn-toggle-gaze" onclick="toggleGazeDot()"
        style="padding:4px 12px;border-radius:6px;border:1px solid #58a6ff;
               background:#21262d;color:#58a6ff;font-size:.72rem;cursor:pointer">
        Show Gaze Dot [H]
      </button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 3 â€“ Results
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ph-results" class="phase">
  <div class="results-hdr">
    <div>
      <h1 id="res-title">Results</h1>
      <div class="sub" id="res-subtitle"></div>
    </div>
    <div class="btn-row">
      <button class="btn btn-blue" onclick="goSelectAnother()">Try Another Method</button>
      <button class="btn btn-save" onclick="saveResults()">â¬‡ Save Results</button>
      <button class="btn btn-grey" onclick="showPhase('ph-select')">â† Menu</button>
    </div>
  </div>

  <!-- Latest run: wave charts -->
  <div class="section" id="sec-wave">
    <h2>Per-Dot Gaze Consistency (Euclidean Distance over Time)</h2>
    <div class="dot-grid" id="dot-grid-latest"></div>
  </div>

  <!-- Latest run: summary table -->
  <div class="section" id="sec-table">
    <h2>Summary â€” Mean Euclidean Distance per Dot</h2>
    <table class="tbl" id="summary-table">
      <thead>
        <tr>
          <th>Dot</th><th>Position (px)</th>
          <th>Mean Error (px)</th><th>Min (px)</th><th>Max (px)</th><th>Samples</th>
        </tr>
      </thead>
      <tbody id="summary-tbody"></tbody>
    </table>
  </div>

  <!-- Comparison (shown when 2+ runs) -->
  <div class="section" id="sec-compare" style="display:none">
    <h2>Method Comparison</h2>
    <div class="cmp-grid" id="cmp-per-method-cards"></div>
    <div class="cmp-big-chart">
      <h3>Mean Error per Dot â€” All Methods</h3>
      <canvas id="compare-chart" style="max-height:300px"></canvas>
    </div>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const CAL_POSITIONS_PCT = [
  [10,10],[50,10],[90,10],
  [10,50],[50,50],[90,50],
  [10,90],[50,90],[90,90]
];
const DOT_DURATION_MS   = 10000;  // total dot display time
const SKIP_MS           = 1000;   // initial skip (user moves gaze)
const SAMPLE_INTERVAL   = 67;     // ~15 fps collection rate
const CAL_COLLECT_FRAMES = 45;    // ~3 s of iris calibration per dot
let   WG_CLICKS_NEEDED  = 5;      // clicks per WebGazer calibration dot (user-configurable)

const METHOD_LABELS = {
  'webgazer':    'WebGazer (Ridge Regression)',
  'iris-linear': 'Iris Linear Regression',
  'iris-poly':   'Iris Polynomial Regression'
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let selectedMethod = null;
let allRuns        = [];       // all completed run result objects
let latestRunIdx   = -1;

// Iris method state
let videoEl    = null;
let camStream  = null;
let faceMesh   = null;
let faceLoopId = null;
let currentLM  = null;  // latest MediaPipe landmarks

// Calibration state
let calIndex      = 0;
let calData       = [];   // [{featureVec, sx, sy}]
let calDotSamples = [];   // iris features collected for current dot
let calCollecting = false;
let calCollectId  = null;
let calFrameCount = 0;
let wgClickCount   = 0;
let calDotEls      = [];
let calModel       = null; // fitted regression model
// WebGazer multi-round calibration
let calTotalRounds = 1;   // total full sweeps through all 9 dots
let calRound       = 0;   // current round (0-indexed)
let calDotTotal    = [];  // cumulative click count per dot across all rounds

// WebGazer state
let wgRunning   = false;
let wgGaze      = null;  // latest {x, y}

// Visibility toggles
let gazeVisible = false;  // hidden by default; press H to show
let selectDrawId = null;  // draw loop for select page camera landmarks

// Experiment state
let expDotIndex  = 0;
let expSamples   = [];   // current dot's gaze samples
let expResults   = [];   // completed dot results for current run
let expSampleId   = null;
let expDotTimer   = null;  // setTimeout: advance to next dot
let expCountdownId = null; // setInterval: countdown display only
let expDotStart  = null;

// Chart instances (to destroy before re-creating)
let dotChartInstances  = [];
let compareChartInst   = null;
let methodBarCharts    = [];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MATRIX MATH (for linear regression)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function matTranspose(A) {
  return A[0].map((_,j) => A.map(r => r[j]));
}
function matMul(A, B) {
  const m = A.length, n = B[0].length, k = B.length;
  const C = Array.from({length:m}, ()=> new Array(n).fill(0));
  for (let i=0;i<m;i++) for (let j=0;j<n;j++) for (let l=0;l<k;l++)
    C[i][j] += A[i][l] * B[l][j];
  return C;
}
function solveGaussian(A, b) {
  // Solve Ax=b via Gaussian elimination with partial pivoting
  const n = A.length;
  const M = A.map((row,i) => [...row, b[i]]);
  for (let col=0; col<n; col++) {
    let mx = col;
    for (let r=col+1;r<n;r++) if (Math.abs(M[r][col]) > Math.abs(M[mx][col])) mx=r;
    [M[col], M[mx]] = [M[mx], M[col]];
    if (Math.abs(M[col][col]) < 1e-12) continue;
    for (let r=0;r<n;r++) {
      if (r===col) continue;
      const f = M[r][col] / M[col][col];
      for (let k=col; k<=n; k++) M[r][k] -= f * M[col][k];
    }
  }
  return M.map((row,i) => row[n] / row[i]);
}
function fitModel(featureMatrix, targets) {
  // featureMatrix: nÃ—p, targets: nÃ—2 ([[sx,sy],...])
  const X  = featureMatrix;
  const XT = matTranspose(X);
  const XTX = matMul(XT, X);
  const XTy_x = matMul(XT, targets.map(t => [t[0]])).map(r => r[0]);
  const XTy_y = matMul(XT, targets.map(t => [t[1]])).map(r => r[0]);
  return {
    theta_x: solveGaussian(XTX.map(r=>[...r]), [...XTy_x]),
    theta_y: solveGaussian(XTX.map(r=>[...r]), [...XTy_y])
  };
}
function modelPredict(model, fv) {
  const x = fv.reduce((s,v,i) => s + v*model.theta_x[i], 0);
  const y = fv.reduce((s,v,i) => s + v*model.theta_y[i], 0);
  return {x, y};
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   IRIS FEATURE EXTRACTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function extractIrisFeatures() {
  if (!currentLM || currentLM.length < 478) return null;
  const lm = currentLM;
  const W  = videoEl ? (videoEl.videoWidth  || 640) : 640;
  const H  = videoEl ? (videoEl.videoHeight || 480) : 480;
  const px = pt => ({x: pt.x*W, y: pt.y*H});

  // Left eye: outer=33, inner=133, upper=160, lower=144, iris=468
  const lo = px(lm[33]), li = px(lm[133]);
  const lu = px(lm[160]), ll = px(lm[144]);
  const lc = px(lm[468]);
  const lew = Math.abs(lo.x - li.x) || 1;
  const leh = Math.abs(lu.y - ll.y) || 1;
  const lx  = (lc.x - Math.min(lo.x, li.x)) / lew;
  const ly  = (lc.y - Math.min(lu.y, ll.y)) / leh;

  // Right eye: outer=362, inner=263, upper=385, lower=373, iris=473
  const ro = px(lm[362]), ri = px(lm[263]);
  const ru = px(lm[385]), rl = px(lm[373]);
  const rc = px(lm[473]);
  const rew = Math.abs(ro.x - ri.x) || 1;
  const reh = Math.abs(ru.y - rl.y) || 1;
  const rx  = (rc.x - Math.min(ro.x, ri.x)) / rew;
  const ry  = (rc.y - Math.min(ru.y, rl.y)) / reh;

  return {lx, ly, rx, ry};
}

function makeFeatureVector(feat) {
  const {lx, ly, rx, ry} = feat;
  if (selectedMethod === 'iris-linear') {
    // [bias, lx, ly, rx, ry]
    return [1, lx, ly, rx, ry];
  } else {
    // iris-poly: average iris position + polynomial terms
    const ax = (lx+rx)/2, ay = (ly+ry)/2;
    return [1, ax, ay, ax*ax, ay*ay, ax*ay];
  }
}

function getCurrentGaze() {
  if (selectedMethod === 'webgazer') {
    return wgGaze ? {...wgGaze} : null;
  }
  if (!calModel) return null;
  const feat = extractIrisFeatures();
  if (!feat) return null;
  const fv = makeFeatureVector(feat);
  return modelPredict(calModel, fv);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CAMERA & MEDIAPIPE (for iris methods)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function initCamera() {
  if (camStream) return; // already started on page load
  videoEl = document.getElementById('cam-preview');
  camStream = await navigator.mediaDevices.getUserMedia({
    video: {width:640, height:480, facingMode:'user'}
  });
  videoEl.srcObject = camStream;
  await new Promise(r => videoEl.addEventListener('loadeddata', r, {once:true}));
}

async function initFaceMesh() {
  if (faceMesh) return; // already initialized on page load
  if (typeof FaceMesh === 'undefined') throw new Error('MediaPipe FaceMesh not loaded');
  faceMesh = new FaceMesh({locateFile: f => `/mediapipe/face_mesh/${f}`});
  faceMesh.setOptions({
    maxNumFaces: 1, refineLandmarks: true,
    minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
  });
  faceMesh.onResults(res => {
    currentLM = (res.multiFaceLandmarks && res.multiFaceLandmarks[0]) || null;
  });
  await faceMesh.initialize();
}

function startFaceLoop() {
  if (faceLoopId) return; // already running
  async function loop() {
    if (videoEl && videoEl.readyState >= 2 && !videoEl.paused) {
      try { await faceMesh.send({image: videoEl}); } catch(_){}
    }
    faceLoopId = setTimeout(loop, 66);
  }
  loop();
}

function stopFaceLoop() {
  clearTimeout(faceLoopId);
  faceLoopId = null;
}

function startSelectDraw() {
  if (selectDrawId || !faceMesh) return;
  const canvas = document.getElementById('cam-canvas');
  if (!canvas) return;
  canvas.width = 240; canvas.height = 180;
  function loop() {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 240, 180);
    if (currentLM) {
      ctx.fillStyle = 'rgba(88,166,255,0.85)';
      currentLM.forEach(({x, y}) => {
        ctx.beginPath();
        ctx.arc(x * 240, y * 180, 1, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    selectDrawId = setTimeout(loop, 66);
  }
  loop();
}

function stopSelectDraw() {
  clearTimeout(selectDrawId);
  selectDrawId = null;
}

function stopCamera() {
  stopFaceLoop();
  if (camStream) { camStream.getTracks().forEach(t => t.stop()); camStream = null; }
  if (videoEl) videoEl.classList.remove('show');
  currentLM = null;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UI HELPERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showPhase(id) {
  document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if (id === 'ph-select') {
    if (!faceLoopId) startFaceLoop();
    startSelectDraw();
  } else {
    stopSelectDraw();
  }
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.style.display = 'block';
  setTimeout(()=> t.style.display='none', 2500);
}

function updateGazeDot(x, y) {
  const d = document.getElementById('gaze-dot-exp');
  if (x == null || !gazeVisible) { d.style.display = 'none'; return; }
  d.style.display = 'block';
  d.style.left = x + 'px';
  d.style.top  = y + 'px';
}

function pctToPx(pct) {
  return {
    x: window.innerWidth  * pct[0] / 100,
    y: window.innerHeight * pct[1] / 100
  };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   METHOD SELECTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function selectMethod(m) {
  selectedMethod = m;
  ['webgazer','iris-linear','iris-poly'].forEach(id => {
    document.getElementById('mc-'+id).classList.toggle('sel', id===m);
  });
  document.getElementById('btn-start-exp').disabled = false;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CALIBRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function beginCalibration() {
  if (!selectedMethod) return;
  // Read configurable clicks setting for WebGazer
  const clicksInput = document.getElementById('wg-clicks-input');
  WG_CLICKS_NEEDED = Math.min(20, Math.max(1, parseInt(clicksInput.value) || 5));
  showPhase('ph-calibrate');

  // Reset calibration state
  calIndex = 0; calData = []; calDotSamples = [];
  calCollecting = false; calFrameCount = 0; wgClickCount = 0;
  calModel = null; wgGaze = null;
  calTotalRounds = 1; calRound = 0; calDotTotal = [];
  dotChartInstances.forEach(c => c.destroy()); dotChartInstances = [];

  const overlay = document.getElementById('cal-overlay');
  overlay.classList.add('show');

  // Remove old dots
  calDotEls.forEach(d => d.remove()); calDotEls = [];

  if (selectedMethod === 'webgazer') {
    await startWebGazerCalibration(overlay);
  } else {
    await startIrisCalibration(overlay);
  }
}

/* â”€â”€ WebGazer calibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const WG_CLICKS_PER_ROUND = 5; // fixed step: 5 clicks per dot per round

function wgClicksForRound(round) {
  // All rounds = 5 clicks, except possibly the last if total not divisible by 5
  const remainder = WG_CLICKS_NEEDED % WG_CLICKS_PER_ROUND;
  const isLast = round === calTotalRounds - 1;
  return (isLast && remainder !== 0) ? remainder : Math.min(WG_CLICKS_PER_ROUND, WG_CLICKS_NEEDED);
}

function updateWgProgText() {
  document.getElementById('cal-prog').textContent =
    'Round ' + (calRound + 1) + ' / ' + calTotalRounds +
    '  â€¢  Dot ' + (calIndex + 1) + ' / 9';
}

async function startWebGazerCalibration(overlay) {
  // Compute rounds: e.g. 20 clicks â†’ 4 rounds of 5; 7 clicks â†’ round1=5, round2=2
  calTotalRounds = Math.ceil(WG_CLICKS_NEEDED / WG_CLICKS_PER_ROUND);
  calRound       = 0;
  calDotTotal    = new Array(9).fill(0);

  document.getElementById('cal-title').textContent = 'WebGazer Calibration';
  document.getElementById('cal-desc').innerHTML =
    'Look at each <span style="color:#f0c000">yellow dot</span> and ' +
    '<b>click it ' + wgClicksForRound(0) + ' times</b>.<br>' +
    calTotalRounds + ' round' + (calTotalRounds > 1 ? 's' : '') +
    ' Ã— ' + WG_CLICKS_PER_ROUND + ' clicks  =  <b>' + WG_CLICKS_NEEDED + ' total</b> per dot';
  document.getElementById('cal-bar-wrap').style.display = 'none';

  try {
    if (wgRunning) { webgazer.end(); wgRunning = false; }
    await webgazer.setGazeListener(data => { if(data) wgGaze = {x:data.x, y:data.y}; }).begin();
    webgazer.showPredictionPoints(false);
    webgazer.showVideo(false);
    webgazer.showFaceOverlay(false);
    webgazer.showFaceFeedbackBox(false);
    wgRunning = true;
  } catch(e) {
    document.getElementById('cal-msg').textContent = 'Error: ' + e.message;
    return;
  }

  buildCalDots(overlay, onWgDotClick);
  activateCalDot(0);
  updateWgProgText();
}

function onWgDotClick(idx) {
  if (idx !== calIndex) return;
  const dot      = calDotEls[idx];
  const {x, y}   = pctToPx(CAL_POSITIONS_PCT[idx]);
  const roundMax = wgClicksForRound(calRound);

  webgazer.recordScreenPosition(x, y, 'click');
  wgClickCount++;
  calDotTotal[idx]++;

  // Label: cumulative / total needed
  dot.textContent   = calDotTotal[idx] + '/' + WG_CLICKS_NEEDED;
  dot.style.fontSize = '.65rem';

  if (wgClickCount >= roundMax) {
    // Finished this dot for this round
    wgClickCount = 0;
    dot.classList.remove('active');

    if (calIndex < 8) {
      // Move to next dot in the same round
      calIndex++;
      activateCalDot(calIndex);
      updateWgProgText();
    } else {
      // Finished all 9 dots â€” end of round
      calRound++;
      if (calRound >= calTotalRounds) {
        // All rounds complete
        calDotEls.forEach(d => {
          d.classList.remove('active'); d.classList.add('done');
          d.textContent = 'âœ“'; d.style.fontSize = '';
        });
        finishWebGazerCalibration();
      } else {
        // Start next round: reset all dots to normal, go back to dot 1
        const nextRoundClicks = wgClicksForRound(calRound);
        calDotEls.forEach((d, i) => {
          d.classList.remove('active', 'done');
          d.textContent   = calDotTotal[i] + '/' + WG_CLICKS_NEEDED;
          d.style.fontSize = '.65rem';
        });
        document.getElementById('cal-desc').innerHTML =
          'Round ' + (calRound + 1) + ' of ' + calTotalRounds +
          ' â€” click each dot <b>' + nextRoundClicks + ' more times</b>';
        calIndex = 0;
        activateCalDot(0);
        updateWgProgText();
      }
    }
  }
}

function finishWebGazerCalibration() {
  document.getElementById('cal-prog').textContent = 'âœ“ Calibration complete!';
  document.getElementById('cal-overlay').classList.remove('show');
  setTimeout(showReadyPhase, 600);
}

/* â”€â”€ Iris calibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function startIrisCalibration(overlay) {
  document.getElementById('cal-title').textContent =
    selectedMethod === 'iris-linear' ? 'Iris Linear â€” Calibration' : 'Iris Polynomial â€” Calibration';
  document.getElementById('cal-desc').innerHTML =
    'Look at each <span style="color:#f0c000">yellow dot</span>, then <b>click it once</b>.<br>' +
    'Hold your gaze steady. Data is collected automatically (3 s).';
  document.getElementById('cal-prog').textContent = 'Dot 1 / 9';
  document.getElementById('cal-bar-wrap').style.display = 'block';
  document.getElementById('cal-bar-fill').style.width = '0%';

  try {
    if (!camStream) await initCamera();
    if (!faceMesh)  await initFaceMesh();
    if (!faceLoopId) startFaceLoop();
  } catch(e) {
    document.getElementById('cal-msg').textContent = 'Camera/MediaPipe error: ' + e.message;
    return;
  }

  buildCalDots(overlay, onIrisDotClick);
  activateCalDot(0);
}

function onIrisDotClick(idx) {
  if (idx !== calIndex || calCollecting) return;
  const {x, y} = pctToPx(CAL_POSITIONS_PCT[idx]);
  startIrisCollection(idx, x, y);
}

function startIrisCollection(idx, sx, sy) {
  calCollecting = true;
  calDotSamples = [];
  calFrameCount = 0;

  const dot = calDotEls[idx];
  dot.classList.remove('active'); dot.classList.add('collecting');
  dot.textContent = 'â€¦';
  document.getElementById('cal-bar-fill').style.width = '0%';
  document.getElementById('cal-msg').textContent = '';

  calCollectId = setInterval(() => {
    const feat = extractIrisFeatures();
    if (feat) calDotSamples.push(feat);
    calFrameCount++;

    const pct = calFrameCount / CAL_COLLECT_FRAMES * 100;
    document.getElementById('cal-bar-fill').style.width = pct + '%';

    if (calFrameCount >= CAL_COLLECT_FRAMES) {
      clearInterval(calCollectId);
      calCollecting = false;
      finishIrisCalDot(idx, sx, sy);
    }
  }, 67);
}

function finishIrisCalDot(idx, sx, sy) {
  if (calDotSamples.length < 5) {
    document.getElementById('cal-msg').textContent =
      'No face detected â€” look at dot and click again.';
    const dot = calDotEls[idx];
    dot.classList.remove('collecting'); dot.classList.add('active');
    dot.textContent = idx+1;
    return;
  }

  // Average features
  const n = calDotSamples.length;
  const avgFeat = {
    lx: calDotSamples.reduce((s,f)=>s+f.lx,0)/n,
    ly: calDotSamples.reduce((s,f)=>s+f.ly,0)/n,
    rx: calDotSamples.reduce((s,f)=>s+f.rx,0)/n,
    ry: calDotSamples.reduce((s,f)=>s+f.ry,0)/n
  };
  const fv = makeFeatureVector(avgFeat);
  calData.push({featureVec: fv, sx, sy});

  const dot = calDotEls[idx];
  dot.classList.remove('collecting'); dot.classList.add('done');
  dot.textContent = 'âœ“';

  calIndex++;
  if (calIndex < 9) {
    activateCalDot(calIndex);
    document.getElementById('cal-prog').textContent = 'Dot ' + (calIndex+1) + ' / 9';
    document.getElementById('cal-bar-fill').style.width = '0%';
  } else {
    finishIrisCalibration();
  }
}

function finishIrisCalibration() {
  // Fit the regression model
  const featureMatrix = calData.map(d => d.featureVec);
  const targets       = calData.map(d => [d.sx, d.sy]);
  calModel = fitModel(featureMatrix, targets);

  document.getElementById('cal-prog').textContent = 'âœ“ Calibration complete!';
  document.getElementById('cal-overlay').classList.remove('show');
  setTimeout(showReadyPhase, 600);
}

/* â”€â”€ Cal dot helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function buildCalDots(overlay, clickHandler) {
  CAL_POSITIONS_PCT.forEach(([lp, tp], i) => {
    const d = document.createElement('div');
    d.className = 'cal-dot';
    d.style.left = lp + '%'; d.style.top = tp + '%';
    d.textContent = i + 1;
    d.addEventListener('click', () => clickHandler(i));
    overlay.appendChild(d);
    calDotEls.push(d);
  });
}

function activateCalDot(idx) {
  calDotEls.forEach((d, i) => {
    d.classList.toggle('active', i === idx);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EXPERIMENT RUNNER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function toggleGazeDot() {
  gazeVisible = !gazeVisible;
  const btn = document.getElementById('btn-toggle-gaze');
  btn.textContent   = gazeVisible ? 'Hide Gaze Dot [H]' : 'Show Gaze Dot [H]';
  btn.style.color   = gazeVisible ? '#8b949e' : '#58a6ff';
  btn.style.borderColor = gazeVisible ? '#30363d' : '#58a6ff';
  if (!gazeVisible) document.getElementById('gaze-dot-exp').style.display = 'none';
}


function showReadyPhase() {
  document.getElementById('ready-title').textContent = 'Calibration Complete âœ“';
  document.getElementById('ready-method').textContent = 'Method: ' + METHOD_LABELS[selectedMethod];
  showPhase('ph-ready');
}

/* Render a full-screen heatmap canvas for a set of gaze samples and return PNG data URL */
function renderHeatmap(samples, gtX, gtY) {
  const W = window.innerWidth, H = window.innerHeight;
  const canvas = document.createElement('canvas');
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);
  // Gaussian blobs for each sample
  const r = 60;
  samples.forEach(({x, y}) => {
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0,   'rgba(255,80,80,0.28)');
    g.addColorStop(0.5, 'rgba(255,200,0,0.09)');
    g.addColorStop(1,   'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(Math.max(0,x-r), Math.max(0,y-r), r*2, r*2);
  });
  // Target marker
  ctx.beginPath(); ctx.arc(gtX, gtY, 10, 0, Math.PI*2);
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2; ctx.stroke();
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(gtX-8, gtY); ctx.lineTo(gtX+8, gtY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(gtX, gtY-8); ctx.lineTo(gtX, gtY+8); ctx.stroke();
  return canvas.toDataURL('image/png');
}

function startExperiment() {
  expDotIndex = 0; expResults = []; expSamples = [];
  // Gaze dot: hidden by default
  gazeVisible = false;
  document.getElementById('gaze-dot-exp').style.display = 'none';
  const btn = document.getElementById('btn-toggle-gaze');
  btn.textContent = 'Show Gaze Dot [H]';
  btn.style.color = '#58a6ff'; btn.style.borderColor = '#58a6ff';
  document.getElementById('exp-method-name').textContent = METHOD_LABELS[selectedMethod];
  document.body.classList.add('cursor-hidden');
  if (selectedMethod === 'webgazer' && wgRunning) {
    try { webgazer.removeMouseEventListeners(); } catch(_) {}
  }
  showPhase('ph-experiment');
  setTimeout(showNextDot, 500);
}

function showNextDot() {
  if (expDotIndex >= CAL_POSITIONS_PCT.length) {
    finishExperiment();
    return;
  }

  const pct = CAL_POSITIONS_PCT[expDotIndex];
  const {x, y} = pctToPx(pct);

  // Position and show dot
  const dot = document.getElementById('exp-dot');
  dot.style.left = x + 'px'; dot.style.top = y + 'px';
  dot.classList.add('show');

  document.getElementById('exp-progress').textContent =
    'Dot ' + (expDotIndex+1) + ' / 9';

  const badge = document.getElementById('exp-collect-badge');
  badge.textContent = 'Waiting 1 sâ€¦';
  badge.className = 'exp-collect-badge';

  expSamples = [];
  expDotStart = performance.now();

  // Count-down timer
  let elapsed = 0;
  const timerEl = document.getElementById('exp-timer');
  timerEl.textContent = (DOT_DURATION_MS / 1000).toFixed(0);

  if (expCountdownId) clearInterval(expCountdownId);
  expCountdownId = setInterval(() => {
    elapsed += 100;
    const remaining = Math.max(0, (DOT_DURATION_MS - elapsed) / 1000);
    timerEl.textContent = remaining.toFixed(1);
    if (elapsed >= DOT_DURATION_MS) { clearInterval(expCountdownId); expCountdownId = null; }
  }, 100);

  // Start data collection after SKIP_MS
  setTimeout(() => {
    badge.textContent = 'â— Collectingâ€¦';
    badge.className = 'exp-collect-badge collecting';
    expSampleId = setInterval(collectGazeSample, SAMPLE_INTERVAL);
  }, SKIP_MS);

  // Move to next after DOT_DURATION_MS
  expDotTimer = setTimeout(() => {
    clearInterval(expSampleId);
    clearInterval(expCountdownId); expCountdownId = null;
    dot.classList.remove('show');
    updateGazeDot(null, null);
    expResults.push({
      gtX: x, gtY: y, pct,
      samples: [...expSamples],
      heatmapUrl: renderHeatmap([...expSamples], x, y)
    });
    expDotIndex++;
    setTimeout(showNextDot, 500);
  }, DOT_DURATION_MS);
}

function collectGazeSample() {
  const g = getCurrentGaze();
  if (!g) return;
  const t = (performance.now() - expDotStart - SKIP_MS) / 1000;
  const pct = CAL_POSITIONS_PCT[expDotIndex];
  const {x: gtX, y: gtY} = pctToPx(pct);
  const dist = Math.hypot(g.x - gtX, g.y - gtY);
  expSamples.push({t, x: g.x, y: g.y, dist});
  updateGazeDot(g.x, g.y);
}

function finishExperiment() {
  updateGazeDot(null, null);
  document.getElementById('exp-dot').classList.remove('show');
  document.body.classList.remove('cursor-hidden');
  if (selectedMethod === 'webgazer' && wgRunning) {
    try { webgazer.addMouseEventListeners(); } catch(_) {}
  }

  // Build run result
  const dotResults = expResults.map((r, i) => {
    const dists = r.samples.map(s => s.dist);
    const mean  = dists.length ? dists.reduce((a,b)=>a+b,0)/dists.length : 0;
    const min   = dists.length ? Math.min(...dists) : 0;
    const max   = dists.length ? Math.max(...dists) : 0;
    return {
      dotIdx: i,
      gtX: Math.round(r.gtX), gtY: Math.round(r.gtY),
      pct: r.pct,
      samples: r.samples,
      heatmapUrl: r.heatmapUrl || null,
      mean: +mean.toFixed(1), min: +min.toFixed(1), max: +max.toFixed(1)
    };
  });

  const overallMean = +(dotResults.reduce((s,d)=>s+d.mean,0)/dotResults.length).toFixed(1);

  const run = {
    method:         selectedMethod,
    label:          METHOD_LABELS[selectedMethod],
    timestamp:      new Date().toISOString(),
    wgClicksPerDot: selectedMethod === 'webgazer' ? WG_CLICKS_NEEDED : undefined,
    dotResults,
    overallMean
  };

  allRuns.push(run);
  latestRunIdx = allRuns.length - 1;

  stopFaceLoop(); // stopped here; restarted by showPhase('ph-select') if user returns

  renderResults(latestRunIdx);
  showPhase('ph-results');
  updateRunsList();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESULTS RENDERING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function renderResults(runIdx) {
  const run = allRuns[runIdx];

  // Header
  document.getElementById('res-title').textContent = run.label + ' â€” Results';
  const d = new Date(run.timestamp);
  document.getElementById('res-subtitle').textContent =
    d.toLocaleDateString() + ' ' + d.toLocaleTimeString() +
    '   |   Overall Mean Error: ' + run.overallMean + ' px';

  // Destroy old dot charts
  dotChartInstances.forEach(c => c.destroy());
  dotChartInstances = [];

  // Build 9-dot wave grid
  const grid = document.getElementById('dot-grid-latest');
  grid.innerHTML = '';

  run.dotResults.forEach((dr, i) => {
    const distClass = dr.mean < 80 ? 'good' : dr.mean < 160 ? 'ok' : 'bad';
    const card = document.createElement('div');
    card.className = 'dot-card';

    const canvasId = 'dc-canvas-' + i;
    card.innerHTML = `
      <div class="dc-hdr">
        <h4>Dot ${i+1} (${dr.pct[0]}%, ${dr.pct[1]}%)</h4>
        <span class="dc-dist ${distClass}">${dr.mean} px</span>
      </div>
      <div class="dc-pos">Ground truth: (${dr.gtX}, ${dr.gtY}) px</div>
      <canvas id="${canvasId}" class="dc-chart"></canvas>
      ${dr.heatmapUrl ? `<img class="dc-heatmap" src="${dr.heatmapUrl}" alt="Heatmap dot ${i+1}"/>` : ''}
    `;
    grid.appendChild(card);

    // Wave chart
    const ctx = document.getElementById(canvasId).getContext('2d');
    const labels = dr.samples.map(s => s.t.toFixed(1));
    const data   = dr.samples.map(s => s.dist);
    const inst = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: 'Euclidean dist (px)',
          data,
          borderColor: '#58a6ff',
          backgroundColor: 'rgba(88,166,255,0.08)',
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.3,
          fill: true
        },{
          label: 'Mean',
          data: Array(data.length).fill(dr.mean),
          borderColor: '#f85149',
          borderWidth: 1,
          borderDash: [4,3],
          pointRadius: 0
        }]
      },
      options: {
        animation: false,
        plugins: {legend: {display:false}},
        scales: {
          x: {
            ticks: {color:'#8b949e', maxTicksLimit:5, font:{size:9}},
            grid:  {color:'#21262d'},
            title: {display:true, text:'Time (s)', color:'#8b949e', font:{size:9}}
          },
          y: {
            ticks: {color:'#8b949e', font:{size:9}},
            grid:  {color:'#21262d'},
            title: {display:true, text:'px', color:'#8b949e', font:{size:9}}
          }
        }
      }
    });
    dotChartInstances.push(inst);
  });

  // Summary table
  const tbody = document.getElementById('summary-tbody');
  tbody.innerHTML = '';
  run.dotResults.forEach((dr, i) => {
    const distClass = dr.mean < 80 ? '#3fb950' : dr.mean < 160 ? '#f0c000' : '#f85149';
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>Dot ${i+1}</td>
      <td>(${dr.gtX}, ${dr.gtY})</td>
      <td style="color:${distClass};font-weight:600">${dr.mean}</td>
      <td>${dr.min}</td><td>${dr.max}</td><td>${dr.samples.length}</td>`;
    tbody.appendChild(tr);
  });
  // Total row
  const tr = document.createElement('tr');
  tr.className = 'total';
  tr.innerHTML = `<td colspan="2">Overall Average</td>
    <td>${run.overallMean}</td><td>â€“</td><td>â€“</td>
    <td>${run.dotResults.reduce((s,d)=>s+d.samples.length,0)}</td>`;
  tbody.appendChild(tr);

  // Comparison section
  renderComparison();
}

function renderComparison() {
  const sec = document.getElementById('sec-compare');
  if (allRuns.length < 2) { sec.style.display='none'; return; }
  sec.style.display = 'block';

  // Per-method summary cards
  const cardsEl = document.getElementById('cmp-per-method-cards');
  cardsEl.innerHTML = '';
  methodBarCharts.forEach(c => c.destroy()); methodBarCharts = [];

  allRuns.forEach((run, ri) => {
    const card = document.createElement('div');
    card.className = 'cmp-card';
    const canvasId = 'cmp-bar-' + ri;
    const tagClass = run.method === 'webgazer' ? 'tag-wg' : run.method === 'iris-linear' ? 'tag-ml' : 'tag-poly';
    card.innerHTML = `
      <h3>${run.label}
        <span class="cmp-method-tag ${tagClass}">
          ${run.overallMean} px avg
        </span>
      </h3>
      <canvas id="${canvasId}" style="height:200px;width:100%"></canvas>`;
    cardsEl.appendChild(card);

    const ctx = document.getElementById(canvasId).getContext('2d');
    const inst = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: run.dotResults.map((_,i)=>'Dot '+(i+1)),
        datasets: [{
          label: 'Mean error (px)',
          data: run.dotResults.map(d=>d.mean),
          backgroundColor: 'rgba(88,166,255,0.7)',
          borderColor: '#58a6ff', borderWidth: 1
        }]
      },
      options: {
        animation: false,
        plugins: {legend:{display:false}},
        scales: {
          x: {ticks:{color:'#8b949e',font:{size:9}}, grid:{color:'#21262d'}},
          y: {ticks:{color:'#8b949e',font:{size:9}}, grid:{color:'#21262d'},
              title:{display:true,text:'px',color:'#8b949e',font:{size:9}}}
        }
      }
    });
    methodBarCharts.push(inst);
  });

  // Big comparison chart: grouped bars
  if (compareChartInst) { compareChartInst.destroy(); compareChartInst = null; }
  const ctx = document.getElementById('compare-chart').getContext('2d');
  const dotLabels = allRuns[0].dotResults.map((_,i) => 'Dot '+(i+1)).concat(['Overall']);
  const colors = ['#58a6ff','#3fb950','#f0c000','#f85149','#d2a8ff'];

  const datasets = allRuns.map((run, ri) => ({
    label: run.label,
    data: run.dotResults.map(d=>d.mean).concat([run.overallMean]),
    backgroundColor: colors[ri % colors.length] + 'b3',
    borderColor:     colors[ri % colors.length],
    borderWidth: 1
  }));

  compareChartInst = new Chart(ctx, {
    type: 'bar',
    data: {labels: dotLabels, datasets},
    options: {
      animation: false,
      plugins: {legend:{labels:{color:'#e6edf3',font:{size:11}}}},
      scales: {
        x: {ticks:{color:'#8b949e'}, grid:{color:'#21262d'}},
        y: {
          ticks:{color:'#8b949e'},grid:{color:'#21262d'},
          title:{display:true,text:'Mean Euclidean Distance (px)',
                 color:'#8b949e',font:{size:11}}
        }
      }
    }
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SAVE RESULTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function saveResults() {
  if (!allRuns.length) return;
  const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
  const payload = {
    exportedAt:     new Date().toISOString(),
    screenWidth:    window.innerWidth,
    screenHeight:   window.innerHeight,
    runs: allRuns.map(run => ({
      method:       run.method,
      label:        run.label,
      timestamp:    run.timestamp,
      overallMean:  run.overallMean,
      wgClicksPerDot: run.method === 'webgazer' ? run.wgClicksPerDot : undefined,
      dots: run.dotResults.map(dr => ({
        dotIdx:    dr.dotIdx + 1,
        pct:       dr.pct,
        gtX:       dr.gtX, gtY: dr.gtY,
        meanError: dr.mean,
        minError:  dr.min,
        maxError:  dr.max,
        sampleCount: dr.samples.length,
        timeSeries: dr.samples
      }))
    }))
  };

  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href     = url;
  a.download = `gaze_experiment_${ts}.json`;
  a.click();
  URL.revokeObjectURL(url);

  // Also save a CSV summary
  let csv = 'Run,Method,Dot,PctX,PctY,GroundTruthX,GroundTruthY,MeanError_px,MinError_px,MaxError_px,Samples\n';
  allRuns.forEach((run, ri) => {
    run.dotResults.forEach(dr => {
      csv += [ri+1, '"'+run.label+'"', dr.dotIdx+1,
              dr.pct[0], dr.pct[1], dr.gtX, dr.gtY,
              dr.mean, dr.min, dr.max, dr.samples.length].join(',') + '\n';
    });
  });
  const csvBlob = new Blob([csv], {type:'text/csv'});
  const csvUrl  = URL.createObjectURL(csvBlob);
  const b = document.createElement('a');
  b.href = csvUrl; b.download = `gaze_experiment_${ts}.csv`; b.click();
  URL.revokeObjectURL(csvUrl);

  // Save heatmap PNGs for the latest run
  const latestRun = allRuns[latestRunIdx];
  if (latestRun) {
    latestRun.dotResults.forEach((dr, i) => {
      if (!dr.heatmapUrl) return;
      const a = document.createElement('a');
      a.href = dr.heatmapUrl;
      a.download = `heatmap_dot${i+1}_${ts}.png`;
      setTimeout(() => a.click(), 200 + i * 150); // stagger to avoid browser blocking
    });
  }

  showToast('Saved JSON + CSV + heatmaps!');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NAVIGATION HELPERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function goSelectAnother() {
  document.body.classList.remove('cursor-hidden');
  if (selectedMethod === 'webgazer' && wgRunning) {
    try { webgazer.addMouseEventListeners(); } catch(_) {}
  }
  // Stop any ongoing collection
  clearInterval(expSampleId);
  clearTimeout(expDotTimer);
  clearInterval(expCountdownId); expCountdownId = null;
  clearInterval(calCollectId);

  // Stop WebGazer if running (optional â€” keep it if user wants to reuse)
  // (don't destroy, just unset selection)
  selectedMethod = null;
  ['webgazer','iris-linear','iris-poly'].forEach(id => {
    document.getElementById('mc-'+id).classList.remove('sel');
  });
  document.getElementById('btn-start-exp').disabled = true;

  updateRunsList();
  showPhase('ph-select');
}

function clearAllRuns() {
  allRuns = []; latestRunIdx = -1;
  dotChartInstances.forEach(c => c.destroy()); dotChartInstances = [];
  if (compareChartInst) { compareChartInst.destroy(); compareChartInst = null; }
  methodBarCharts.forEach(c => c.destroy()); methodBarCharts = [];
  updateRunsList();
}

function updateRunsList() {
  const wrap  = document.getElementById('runs-list');
  const inner = document.getElementById('runs-list-inner');
  if (!allRuns.length) { wrap.style.display='none'; return; }
  wrap.style.display = 'block';
  inner.innerHTML = '';
  allRuns.forEach((run, i) => {
    const el = document.createElement('div');
    el.className = 'run-item';
    const d = new Date(run.timestamp);
    const timeStr = d.toLocaleTimeString();
    el.innerHTML = `
      <span class="ri-method">${run.label}</span>
      <span class="ri-dist">~${run.overallMean} px</span>
      <div class="ri-dots">
        ${run.dotResults.map(dr => `<span class="ri-dot-chip">${dr.mean}</span>`).join('')}
      </div>
      <span class="ri-time">${timeStr}</span>
    `;
    el.style.cursor = 'pointer';
    el.onclick = () => { latestRunIdx = i; renderResults(i); showPhase('ph-results'); };
    inner.appendChild(el);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CLEANUP ON PAGE UNLOAD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
// Keyboard shortcuts (active during experiment phase)
// H = toggle gaze dot   G = toggle camera preview
document.addEventListener('keydown', e => {
  if (e.key === 'h' || e.key === 'H') toggleGazeDot();
});

// Start camera + face mesh on page load to show landmark preview on select page
window.addEventListener('load', async () => {
  try {
    videoEl = document.getElementById('cam-preview');
    camStream = await navigator.mediaDevices.getUserMedia({
      video: {width:640, height:480, facingMode:'user'}
    });
    videoEl.srcObject = camStream;
    await new Promise(r => videoEl.addEventListener('loadeddata', r, {once:true}));
    document.getElementById('cam-status').textContent = 'Camera active â€” face landmarks shown';
    if (typeof FaceMesh !== 'undefined') {
      await initFaceMesh();
      startFaceLoop();
      startSelectDraw();
    }
  } catch(e) {
    document.getElementById('cam-status').textContent = 'Camera: ' + (e.message || e);
  }
});

window.addEventListener('beforeunload', () => {
  if (wgRunning) { try { webgazer.end(); } catch(_){} }
  stopCamera();
});
</script>
</body>
</html>
